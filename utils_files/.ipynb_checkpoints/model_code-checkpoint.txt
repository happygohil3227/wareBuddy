# Create the model object m
m = gp.Model('MilkCollection.lp')

# Decision variables: 

# Edge variables = 1, if farm 'i' is adjacent to farm 'j' on the tour of day type 'k'.
vars = m.addVars(dist, dayType, vtype=GRB.BINARY, name='x')

# Other day variables = 1, if farm 'i' is visited on the tour of day type 'k'.
other_var = m.addVars(otherDay, dayType, vtype=GRB.BINARY, name='y') 

# Symmetry constraints: copy the object (not a constraint)
vars.update({(j,i,k):vars[i,j,k] for i,j,k in vars.keys()})

# Every day constraints: two edges incident to an every day farm on tour of day type 'k'. 
m.addConstrs((vars.sum(i,'*',k) == 2 for i in everyDay for k in dayType  ), name='everyDay')

# Other day constraints: two edges incident to an other day farm on tour of day type 'k'.
m.addConstrs((vars.sum(i,'*',k) == 2*other_var[i,k] for i in otherDay for k in dayType ), name='otherDay')

# Tanker capacity constraint.
m.addConstrs(( gp.quicksum(collect[i]*other_var[i,k] for i in otherDay ) <= tankerCap-everyDayReq for k in dayType ),
             name='tankerCap')

# Other day farms are visited on day type 1 or 2.
otherDayFarms = m.addConstrs((other_var.sum(i, '*') == 1 for i in otherDay), name='visited')

# Avoid symmetric alternative solutions
other_var[11,1].lb = 1

# Objective function: minimize total distance travel
m.setObjective(gp.quicksum(dist[i,j]*vars[i,j,k] for i,j in dist.keys() for k in dayType), GRB.MINIMIZE)